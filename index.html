import React, { useEffect, useMemo, useRef, useState } from "react";
import YouTube from "react-youtube";
import { Play, Pause, SkipBack, SkipForward, Maximize2, ListPlus, Music2, Trophy, AlertCircle } from "lucide-react";
import { motion } from "framer-motion";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

// ————————————————————————————————————————————————
// Utilidades
// ————————————————————————————————————————————————
function extractYouTubeId(input) {
  if (!input) return "";
  const idRegex = /(?:v=|\.be\/|embed\/|shorts\/)([a-zA-Z0-9_-]{6,})/;
  if (/^[a-zA-Z0-9_-]{6,}$/.test(input)) return input;
  const m = input.match(idRegex);
  return m ? m[1] : "";
}

function formatTime(seconds) {
  const s = Math.max(0, Math.floor(seconds));
  const m = Math.floor(s / 60).toString().padStart(2, "0");
  const r = (s % 60).toString().padStart(2, "0");
  return `${m}:${r}`;
}

// Nota musical aproximada (para feedback visual)
const A4 = 440;
function freqToNoteName(freq) {
  if (!freq || !isFinite(freq)) return "—";
  const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
  const n = Math.round(12 * Math.log2(freq / A4)) + 69; // MIDI
  const name = noteNames[(n % 12 + 12) % 12];
  const oct = Math.floor(n / 12) - 1;
  return `${name}${oct}`;
}

// Pitch detection por autocorrelação (simples e leve)
function detectPitchAutoCorr(timeDomain, sampleRate) {
  let size = timeDomain.length;
  let sum = 0;
  for (let i = 0; i < size; i++) sum += (timeDomain[i] - 128) * (timeDomain[i] - 128);
  if (sum < 1e6) return null; // sinal fraco

  const buf = new Float32Array(size);
  for (let i = 0; i < size; i++) buf[i] = (timeDomain[i] - 128) / 128;

  let bestOffset = -1;
  let bestCorr = 0;
  let rms = 0;
  for (let i = 0; i < size; i++) rms += buf[i] * buf[i];
  rms = Math.sqrt(rms / size);
  if (rms < 0.01) return null;

  let lastCorr = 1;
  const MAX_LAG = Math.floor(sampleRate / 80); // 80 Hz
  const MIN_LAG = Math.floor(sampleRate / 800); // 800 Hz

  for (let lag = MIN_LAG; lag < MAX_LAG; lag++) {
    let corr = 0;
    for (let i = 0; i < size - lag; i++) corr += buf[i] * buf[i + lag];
    corr = corr / (size - lag);
    if (corr > bestCorr && corr > 0.9 * lastCorr) {
      bestCorr = corr;
      bestOffset = lag;
    }
    lastCorr = corr;
  }
  if (bestOffset > 0) return sampleRate / bestOffset;
  return null;
}

// ————————————————————————————————————————————————
// Componente principal (somente YouTube + pontuação)
// ————————————————————————————————————————————————
export default function KaraokeYouTubeScoring() {
  const [queue, setQueue] = useState([]); // [{id, title}]
  const [url, setUrl] = useState("");
  const [title, setTitle] = useState("");
  const [errorMsg, setErrorMsg] = useState("");
  const [currentIndex, setCurrentIndex] = useState(0);

  const [playerTime, setPlayerTime] = useState(0);
  const [playerState, setPlayerState] = useState(-1);
  const [fallback, setFallback] = useState(false); // usa <iframe> nativo se react-youtube falhar
  const playerRef = useRef(null);
  const timerRef = useRef(null);

  // Mic / áudio
  const [micActive, setMicActive] = useState(false);
  const [currentFreq, setCurrentFreq] = useState(null);
  const [currentNote, setCurrentNote] = useState("—");
  const [volume, setVolume] = useState(0);
  const analyserRef = useRef(null);
  const audioCtxRef = useRef(null);

  // Pontuação
  const [score, setScore] = useState(0);
  const [combo, setCombo] = useState(0);
  const [maxCombo, setMaxCombo] = useState(0);
  const [songStartTs, setSongStartTs] = useState(null);

  const currentVideoId = queue[currentIndex]?.id || null;

  // Player polling
  useEffect(() => {
    clearInterval(timerRef.current);
    timerRef.current = setInterval(async () => {
      const p = playerRef.current;
      if (!p || typeof p.getCurrentTime !== 'function') return;
      try { setPlayerTime((await p.getCurrentTime()) || 0); } catch {}
    }, 120);
    return () => clearInterval(timerRef.current);
  }, []);

  function onReady(e) {
    playerRef.current = e.target;
  }
  function onStateChange(e) {
    setPlayerState(e.data);
    if (e.data === 1 && !songStartTs) setSongStartTs(Date.now());
    if (e.data === 0) setCombo(0); // terminou
  }

  function addToQueue() {
    setErrorMsg("");
    const id = extractYouTubeId(url.trim());
    if (!id) { setErrorMsg("Link/ID do YouTube inválido."); return; }
    setQueue((q) => [...q, { id, title: title.trim() || `Vídeo ${id}` }]);
    setUrl("");
    setTitle("");
    setFallback(false);
    if (queue.length === 0) setCurrentIndex(0);
  }
  function next() { setCurrentIndex((i) => Math.min(i + 1, queue.length - 1)); }
  function prev() { setCurrentIndex((i) => Math.max(i - 1, 0)); }

  async function togglePlay() {
    const p = playerRef.current; if (!p) return;
    const state = playerState;
    if (state === 1) await p.pauseVideo(); else await p.playVideo();
  }
  async function seek(delta) {
    const p = playerRef.current; if (!p) return;
    try {
      const t = await p.getCurrentTime(); await p.seekTo(Math.max(0, t + delta), true);
    } catch {}
  }

  // ——— Captura de microfone + análise ———
  async function toggleMic() {
    try {
      if (micActive) {
        const ctx = audioCtxRef.current; if (ctx) await ctx.close();
        audioCtxRef.current = null; setMicActive(false); return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true }, video: false });
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const src = ctx.createMediaStreamSource(stream);
      const analyser = ctx.createAnalyser();
      analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.85;
      src.connect(analyser);
      analyserRef.current = analyser; audioCtxRef.current = ctx;
      setMicActive(true);
    } catch (e) { setErrorMsg("Permita o microfone para pontuar."); }
  }

  // Loop de análise + pontuação
  useEffect(() => {
    let raf; function loop() {
      const analyser = analyserRef.current; const ctx = audioCtxRef.current;
      if (analyser && ctx) {
        const td = new Uint8Array(analyser.fftSize); analyser.getByteTimeDomainData(td);
        let sum = 0; for (let i = 0; i < td.length; i++) { const v = (td[i] - 128) / 128; sum += v * v; }
        const rms = Math.sqrt(sum / td.length); setVolume(rms);
        const freq = detectPitchAutoCorr(td, ctx.sampleRate); setCurrentFreq(freq); setCurrentNote(freqToNoteName(freq));
        const LIMIAR_VOL = 0.03; const STAB_DELTA = 10;
        loop.prevFreq = loop.prevFreq || freq;
        if (rms > LIMIAR_VOL && freq && loop.prevFreq) {
          if (Math.abs(freq - loop.prevFreq) < STAB_DELTA) {
            setScore((s) => Math.min(100, s + 0.08));
            setCombo((c) => { const nc = c + 1; if (nc > maxCombo) setMaxCombo(nc); return nc; });
          } else { setCombo(0); }
        } else { setCombo(0); }
        loop.prevFreq = freq || loop.prevFreq;
      }
      raf = requestAnimationFrame(loop);
    } raf = requestAnimationFrame(loop); return () => cancelAnimationFrame(raf);
  }, [maxCombo]);

  // Atalhos
  useEffect(() => {
    function h(e) {
      if (e.target && ["INPUT", "TEXTAREA"].includes(e.target.tagName)) return;
      if (e.code === "Space") { e.preventDefault(); togglePlay(); }
      if (e.code === "ArrowRight") seek(5);
      if (e.code === "ArrowLeft") seek(-5);
    }
    window.addEventListener("keydown", h);
    return () => window.removeEventListener("keydown", h);
  }, [playerState]);

  // Fullscreen do painel de pontuação
  const scoreRef = useRef(null);
  async function toggleFullscreen() {
    const el = scoreRef.current; if (!el) return;
    const doc = document; const isFs = doc.fullscreenElement || doc.webkitFullscreenElement;
    if (!isFs) { if (el.requestFullscreen) await el.requestFullscreen(); else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen(); }
    else { if (doc.exitFullscreen) await doc.exitFullscreen(); else if (doc.webkitExitFullscreen) await doc.webkitExitFullscreen(); }
  }

  const opts = useMemo(() => ({
    height: "360",
    width: "100%",
    playerVars: {
      autoplay: 0,
      controls: 1,
      rel: 0,
      modestbranding: 1,
      playsinline: 1,
      origin: typeof window !== 'undefined' ? window.location.origin : undefined,
    },
  }), []);

  // Reset score quando troca de vídeo
  useEffect(() => { setScore(0); setCombo(0); setMaxCombo(0); setSongStartTs(null); }, [currentVideoId]);

  return (
    <div className="min-h-screen w-full bg-white text-slate-900">
      <div className="mx-auto max-w-7xl p-4 md:p-8">
        {/* Header */}
        <div className="flex items-center justify-between gap-4">
          <div className="flex items-center gap-3">
            <Music2 className="h-6 w-6 text-emerald-600" />
            <h1 className="text-xl md:text-2xl font-semibold">Karaokê YouTube — Simples com Pontuação</h1>
          </div>
          <div className="text-xs text-slate-500">v2.1 • Beta</div>
        </div>

        {/* Linha principal */}
        <div className="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Coluna Esquerda: Fila e Entrada */}
          <div className="lg:col-span-1 space-y-6">
            <Card className="bg-white border-slate-200 shadow-sm">
              <CardHeader className="pb-2">
                <CardTitle className="text-base flex items-center gap-2"><ListPlus className="h-4 w-4 text-emerald-600"/>Adicionar vídeo à fila</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <form onSubmit={(e)=>{e.preventDefault(); addToQueue();}} className="grid grid-cols-1 gap-2">
                  <Input placeholder="Cole a URL do YouTube ou ID do vídeo" value={url} onChange={(e)=>setUrl(e.target.value)} className="bg-white border-slate-300"/>
                  <Input placeholder="Título (opcional)" value={title} onChange={(e)=>setTitle(e.target.value)} className="bg-white border-slate-300"/>
                  <Button type="submit" className="w-full bg-emerald-600 hover:bg-emerald-700">Adicionar</Button>
                </form>
                {errorMsg && (
                  <div className="flex items-start gap-2 text-sm text-rose-600">
                    <AlertCircle className="h-4 w-4"/> <span>{errorMsg}</span>
                  </div>
                )}
                <div className="pt-1 text-xs text-slate-500">
                  Dica: funciona com links <code className="bg-slate-100 px-1 rounded">youtube.com</code>, <code className="bg-slate-100 px-1 rounded">youtu.be</code> e Shorts.
                </div>
              </CardContent>
            </Card>

            <Card className="bg-white border-slate-200 shadow-sm">
              <CardHeader className="pb-2">
                <CardTitle className="text-base">Fila ({queue.length})</CardTitle>
              </CardHeader>
              <CardContent>
                {queue.length === 0 ? (
                  <div className="text-sm text-slate-500">Nenhum vídeo ainda. Adicione acima ⬆️</div>
                ) : (
                  <ul className="space-y-2">
                    {queue.map((v, i) => (
                      <li key={v.id+"-"+i} className={`flex items-center justify-between gap-3 rounded-xl border px-3 py-2 ${i===currentIndex?"border-emerald-500 bg-emerald-50":"border-slate-200 bg-white"}`}>
                        <div className="min-w-0">
                          <div className="truncate text-sm font-medium">{v.title}</div>
                          <div className="text-[10px] text-slate-500">ID: {v.id}</div>
                        </div>
                        <div className="flex items-center gap-2">
                          <Button type="button" size="sm" variant="secondary" className="h-7" onClick={()=>setCurrentIndex(i)}>Tocar</Button>
                        </div>
                      </li>
                    ))}
                  </ul>
                )}
                {queue.length>0 && (
                  <div className="mt-3 flex items-center gap-2">
                    <Button type="button" variant="secondary" className="h-8" onClick={prev}><SkipBack className="h-4 w-4"/></Button>
                    <Button type="button" className="h-8 bg-emerald-600 hover:bg-emerald-700" onClick={togglePlay}>{playerState===1? <Pause className="h-4 w-4"/>:<Play className="h-4 w-4"/>}</Button>
                    <Button type="button" variant="secondary" className="h-8" onClick={next}><SkipForward className="h-4 w-4"/></Button>
                  </div>
                )}
              </CardContent>
            </Card>
          </div>

          {/* Coluna Direita: Player + Pontuação */}
          <div className="lg:col-span-2 space-y-6">
            <Card className="bg-white border-slate-200 shadow-sm overflow-hidden">
              <CardHeader className="pb-2">
                <CardTitle className="text-base">Player YouTube</CardTitle>
              </CardHeader>
              <CardContent>
                {currentVideoId ? (
                  !fallback ? (
                    <YouTube
                      videoId={currentVideoId}
                      opts={opts}
                      onReady={onReady}
                      onStateChange={onStateChange}
                      onError={() => setFallback(true)}
                      className="w-full rounded-xl overflow-hidden"
                    />
                  ) : (
                    <iframe
                      className="w-full rounded-xl overflow-hidden"
                      style={{ aspectRatio: '16/9', border: '0' }}
                      src={`https://www.youtube.com/embed/${currentVideoId}?rel=0&modestbranding=1`}
                      title="YouTube player"
                      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                      allowFullScreen
                    />
                  )
                ) : (
                  <div className="h-48 grid place-items-center text-sm text-slate-500">Adicione um vídeo para começar</div>
                )}
                {currentVideoId && (
                  <div className="mt-2 flex items-center justify-between text-xs text-slate-600">
                    <div><span className="font-mono">{formatTime(playerTime)}</span></div>
                    <div className="space-x-2">
                      <Button type="button" size="sm" variant="secondary" onClick={()=>seek(-10)}>−10s</Button>
                      <Button type="button" size="sm" variant="secondary" onClick={()=>seek(-5)}>−5s</Button>
                      <Button type="button" size="sm" variant="secondary" onClick={()=>seek(5)}>+5s</Button>
                      <Button type="button" size="sm" variant="secondary" onClick={()=>seek(10)}>+10s</Button>
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Painel de Pontuação */}
            <Card className="bg-white border-slate-200 shadow-sm">
              <CardHeader className="pb-2 flex items-center justify-between">
                <CardTitle className="text-base flex items-center gap-2"><Trophy className="h-4 w-4 text-emerald-600"/>Pontuação em tempo real</CardTitle>
                <Button size="sm" variant="secondary" onClick={toggleFullscreen} title="Tela cheia do painel">
                  <Maximize2 className="h-4 w-4" />
                </Button>
              </CardHeader>
              <CardContent>
                <div ref={scoreRef} className="relative w-full rounded-2xl border border-slate-200 bg-gradient-to-b from-emerald-50 to-white p-4 overflow-hidden">
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-center">
                    {/* Score Circular */}
                    <div className="flex items-center justify-center">
                      <div className="relative h-36 w-36">
                        <svg viewBox="0 0 120 120" className="h-36 w-36">
                          <circle cx="60" cy="60" r="54" fill="none" stroke="#E2E8F0" strokeWidth="10"/>
                          <circle cx="60" cy="60" r="54" fill="none" stroke="#10B981" strokeWidth="10" strokeLinecap="round"
                            strokeDasharray={`${Math.round((score/100)*339)} 339`} transform="rotate(-90 60 60)"/>
                        </svg>
                        <div className="absolute inset-0 grid place-items-center">
                          <div className="text-center">
                            <div className="text-2xl font-semibold">{Math.round(score)}</div>
                            <div className="text-xs text-slate-500">/ 100</div>
                          </div>
                        </div>
                      </div>
                    </div>

                    {/* Leituras de voz */}
                    <div className="text-center md:text-left space-y-2">
                      <div className="text-sm">Nota detectada: <span className="font-medium">{currentNote}</span></div>
                      <div className="text-sm">Frequência: <span className="font-medium">{currentFreq? `${currentFreq.toFixed(1)} Hz` : "—"}</span></div>
                      <div className="text-sm">Volume: <span className="font-medium">{(volume*100).toFixed(0)}%</span></div>
                      <div className="text-sm">Combo: <span className="font-medium">{combo}x</span> <span className="text-slate-400">(máx. {maxCombo}x)</span></div>
                    </div>

                    {/* Ações do Mic */}
                    <div className="flex md:justify-end justify-center gap-2">
                      <Button type="button" className={`px-4 ${micActive?"bg-emerald-600 hover:bg-emerald-700":"bg-slate-700 hover:bg-slate-800"}`} onClick={toggleMic}>
                        {micActive? "Microfone ligado" : "Ligar microfone"}
                      </Button>
                      <Button type="button" variant="secondary" onClick={()=>{setScore(0); setCombo(0); setMaxCombo(0);}}>
                        Reset Score
                      </Button>
                    </div>
                  </div>

                  <motion.div
                    key={combo}
                    initial={{ opacity: 0, y: 8 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.25 }}
                    className="absolute bottom-3 left-0 right-0 text-center text-sm text-emerald-700"
                  >
                    {combo > 0 ? `Ótimo! Mantém estável para mais pontos (combo ${combo}x)` : "Cante perto do microfone para começar a pontuar"}
                  </motion.div>
                </div>

                <div className="mt-3 text-[11px] text-slate-500">
                  * Pontuação simples baseada em estabilidade de pitch e presença de voz. Não compara com a melodia original do vídeo.
                </div>
              </CardContent>
            </Card>
          </div>
        </div>

        <div className="mt-6 text-[11px] text-slate-500">
          * Protótipo educativo. Use com conteúdo autorizado.
        </div>
      </div>
    </div>
  );
}






